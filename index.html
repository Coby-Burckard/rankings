<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Job Comparison Tool</title>
<style>
  :root {
    --color-bg: #f5f5f5;
    --color-surface: #ffffff;
    --color-text: #212121;
    --color-text-secondary: #757575;
    --color-border: #e0e0e0;
    --color-accent: #1976d2;
    --color-accent-light: #e3f2fd;
    --color-gold: #f9a825;
    --color-silver: #90a4ae;
    --color-bronze: #ff8a65;
    --group-compensation: #e8f5e9;
    --group-career: #e3f2fd;
    --group-worklife: #fff8e1;
    --group-location: #e0f2f1;
    --group-partner: #f3e5f5;
    --sticky-z: 10;
    --header-z: 20;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--color-bg);
    color: var(--color-text);
    line-height: 1.5;
  }

  /* Header */
  .header {
    background: var(--color-surface);
    border-bottom: 1px solid var(--color-border);
    padding: 12px 24px;
    display: flex;
    align-items: center;
    gap: 16px;
    flex-wrap: wrap;
    position: sticky;
    top: 0;
    z-index: var(--header-z);
  }

  .header h1 {
    font-size: 20px;
    font-weight: 700;
    margin-right: auto;
  }

  .header-actions {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
  }

  .btn {
    padding: 6px 14px;
    border: 1px solid var(--color-border);
    border-radius: 6px;
    background: var(--color-surface);
    color: var(--color-text);
    font-size: 13px;
    cursor: pointer;
    transition: background 0.15s, border-color 0.15s;
    white-space: nowrap;
  }

  .btn:hover { background: #f0f0f0; border-color: #bbb; }

  .btn-primary {
    background: var(--color-accent);
    color: white;
    border-color: var(--color-accent);
  }

  .btn-primary:hover { background: #1565c0; }

  .btn-danger { color: #d32f2f; }
  .btn-danger:hover { background: #ffebee; border-color: #d32f2f; }

  .partner-toggle {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 13px;
    cursor: pointer;
    user-select: none;
  }

  .partner-toggle input { cursor: pointer; }

  /* Summary Bar */
  .summary-bar {
    padding: 16px 24px;
    display: flex;
    gap: 12px;
    overflow-x: auto;
    background: var(--color-bg);
  }

  .summary-card {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 10px;
    padding: 14px 20px;
    min-width: 180px;
    flex-shrink: 0;
    position: relative;
    transition: box-shadow 0.2s;
  }

  .summary-card.rank-1 { border-color: var(--color-gold); box-shadow: 0 0 0 1px var(--color-gold); }
  .summary-card.rank-2 { border-color: var(--color-silver); }
  .summary-card.rank-3 { border-color: var(--color-bronze); }

  .rank-badge {
    position: absolute;
    top: -8px;
    right: -8px;
    width: 26px;
    height: 26px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: 700;
    color: white;
  }

  .rank-1 .rank-badge { background: var(--color-gold); }
  .rank-2 .rank-badge { background: var(--color-silver); }
  .rank-3 .rank-badge { background: var(--color-bronze); }

  .summary-name {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 4px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 160px;
  }

  .summary-score {
    font-size: 28px;
    font-weight: 700;
    color: var(--color-accent);
  }

  .summary-completeness {
    font-size: 11px;
    color: var(--color-text-secondary);
    margin-top: 2px;
  }

  /* Empty State */
  .empty-state {
    text-align: center;
    padding: 80px 24px;
    color: var(--color-text-secondary);
  }

  .empty-state h2 { font-size: 22px; margin-bottom: 8px; color: var(--color-text); }
  .empty-state p { margin-bottom: 20px; font-size: 15px; }

  /* Grid Container */
  .grid-wrapper {
    overflow-x: auto;
    padding: 0 24px 40px;
  }

  .grid {
    border-collapse: collapse;
    width: max-content;
    min-width: 100%;
    background: var(--color-surface);
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--color-border);
  }

  .grid th, .grid td {
    padding: 8px 12px;
    text-align: left;
    border-bottom: 1px solid var(--color-border);
    font-size: 13px;
    vertical-align: middle;
  }

  .grid th {
    font-weight: 600;
    background: var(--color-surface);
  }

  /* Sticky columns */
  .col-category {
    position: sticky;
    left: 0;
    z-index: var(--sticky-z);
    background: var(--color-surface);
    min-width: 220px;
    max-width: 220px;
  }

  .col-weight {
    position: sticky;
    left: 220px;
    z-index: var(--sticky-z);
    background: var(--color-surface);
    min-width: 80px;
    width: 80px;
    text-align: center;
  }

  .col-job {
    min-width: 150px;
    width: 150px;
    text-align: center;
  }

  /* Group header row */
  .group-header td {
    font-weight: 700;
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 10px 12px 6px;
    border-bottom: 2px solid var(--color-border);
  }

  .group-header .col-category { display: flex; align-items: center; gap: 6px; }

  /* Category name */
  .cat-name {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .cat-name .info-icon {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #e0e0e0;
    color: #757575;
    font-size: 10px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: help;
    flex-shrink: 0;
  }

  /* Weight dots */
  .weight-dots {
    display: inline-flex;
    gap: 3px;
    cursor: pointer;
  }

  .weight-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 1.5px solid #999;
    background: transparent;
    transition: background 0.1s, border-color 0.1s;
  }

  .weight-dot.filled {
    background: var(--color-accent);
    border-color: var(--color-accent);
  }

  .weight-dots:hover .weight-dot { border-color: var(--color-accent); }

  /* Score input */
  .score-cell {
    position: relative;
  }

  .score-input {
    width: 56px;
    padding: 4px 6px;
    border: 1px solid var(--color-border);
    border-radius: 4px;
    font-size: 14px;
    text-align: center;
    font-weight: 600;
    background: transparent;
    transition: border-color 0.15s;
  }

  .score-input:focus {
    outline: none;
    border-color: var(--color-accent);
    box-shadow: 0 0 0 2px var(--color-accent-light);
  }

  .score-input::placeholder {
    color: #ccc;
    font-weight: 400;
  }

  /* Score cell coloring */
  .score-cell.best-in-row { border-left: 3px solid #4caf50; }
  .score-cell.worst-in-row { border-left: 3px solid #ef5350; }

  /* Job column header */
  .job-header {
    padding: 8px 12px;
    text-align: center;
  }

  .job-name-input {
    width: 120px;
    padding: 4px 6px;
    border: 1px solid transparent;
    border-radius: 4px;
    font-size: 14px;
    font-weight: 700;
    text-align: center;
    background: transparent;
    transition: border-color 0.15s;
  }

  .job-name-input:hover { border-color: var(--color-border); }
  .job-name-input:focus {
    outline: none;
    border-color: var(--color-accent);
    background: white;
  }

  .job-header-actions {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 4px;
    margin-top: 4px;
  }

  .btn-icon {
    width: 24px;
    height: 24px;
    border: none;
    background: transparent;
    cursor: pointer;
    border-radius: 4px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: var(--color-text-secondary);
    transition: background 0.1s, color 0.1s;
  }

  .btn-icon:hover { background: #f0f0f0; color: var(--color-text); }
  .btn-icon.danger:hover { background: #ffebee; color: #d32f2f; }

  /* Notes */
  .notes-row td { padding: 0 12px 8px; border-bottom: 2px solid var(--color-border); }

  .notes-textarea {
    width: 130px;
    padding: 6px 8px;
    border: 1px solid var(--color-border);
    border-radius: 4px;
    font-size: 12px;
    font-family: inherit;
    resize: vertical;
    min-height: 48px;
    max-height: 120px;
  }

  .notes-textarea:focus {
    outline: none;
    border-color: var(--color-accent);
  }

  /* Subtotal row */
  .subtotal-row td {
    font-weight: 600;
    font-size: 12px;
    color: var(--color-text-secondary);
    border-bottom: 2px solid var(--color-border);
    padding: 6px 12px;
  }

  .subtotal-score { font-weight: 700; color: var(--color-text); }

  /* Total row */
  .total-row td {
    font-weight: 700;
    font-size: 15px;
    padding: 12px;
    border-top: 2px solid var(--color-text);
    border-bottom: none;
  }

  .total-score {
    font-size: 18px;
    color: var(--color-accent);
  }

  /* Responsive */
  @media (max-width: 768px) {
    .header { padding: 10px 12px; gap: 10px; }
    .header h1 { font-size: 16px; }
    .summary-bar { padding: 12px; }
    .grid-wrapper { padding: 0 12px 24px; }
    .col-category { min-width: 160px; max-width: 160px; }
    .col-weight { left: 160px; min-width: 60px; width: 60px; }
    .col-job { min-width: 130px; }
    .job-name-input { width: 100px; }
    .score-input { width: 48px; }
  }

  /* Add category row */
  .add-category-btn {
    font-size: 12px;
    color: var(--color-accent);
    cursor: pointer;
    border: none;
    background: none;
    padding: 4px 0;
  }

  .add-category-btn:hover { text-decoration: underline; }

  /* Tooltip */
  [data-tooltip] {
    position: relative;
  }

  [data-tooltip]:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: calc(100% + 6px);
    left: 50%;
    transform: translateX(-50%);
    background: #333;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 11px;
    white-space: nowrap;
    z-index: 100;
    pointer-events: none;
  }

  /* Hidden file input */
  .hidden { display: none; }

  /* ‚îÄ‚îÄ Game ‚îÄ‚îÄ */
  .game-container {
    display: none;
    background: #1a1a2e;
    padding: 20px;
    text-align: center;
    position: relative;
  }

  .game-container.active { display: block; }

  .game-canvas-wrapper {
    position: relative;
    display: inline-block;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    border: 3px solid #333;
  }

  #gameCanvas {
    display: block;
    image-rendering: pixelated;
    background: #2d5a27;
  }

  .game-dialogue {
    display: none;
    position: absolute;
    bottom: 8px;
    left: 8px;
    right: 8px;
    background: rgba(0,0,0,0.92);
    border: 2px solid #fff;
    border-radius: 8px;
    padding: 14px 18px;
    color: #fff;
    font-family: 'Courier New', monospace;
    font-size: 15px;
    line-height: 1.5;
    text-align: left;
    min-height: 70px;
  }

  .game-dialogue.active { display: block; }

  .game-dialogue .speaker {
    color: #7ce87c;
    font-weight: bold;
    margin-bottom: 4px;
  }

  .game-dialogue .prompt-hint {
    color: #aaa;
    font-size: 11px;
    margin-top: 6px;
    text-align: right;
  }

  .game-dialogue .prompt-hint span { animation: blink 1s infinite; }

  @keyframes blink { 0%,100% { opacity:1; } 50% { opacity:0; } }

  .game-header {
    color: #aaa;
    font-size: 12px;
    margin-bottom: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    max-width: 640px;
    margin-left: auto;
    margin-right: auto;
  }

  .game-header span { color: #7ce87c; font-family: 'Courier New', monospace; }

  .btn-close-game {
    padding: 4px 12px;
    background: transparent;
    color: #aaa;
    border: 1px solid #555;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
  }

  .btn-close-game:hover { color: #fff; border-color: #999; }

  .btn-break {
    background: #e8f5e9;
    color: #2e7d32;
    border-color: #a5d6a7;
  }

  .btn-break:hover { background: #c8e6c9; border-color: #81c784; }

  /* Mobile D-pad */
  .game-dpad {
    display: none;
    margin-top: 12px;
    position: relative;
    width: 160px;
    height: 160px;
    margin-left: auto;
    margin-right: auto;
  }

  .game-dpad button {
    position: absolute;
    width: 52px;
    height: 52px;
    border: 2px solid #555;
    background: rgba(255,255,255,0.1);
    color: #ccc;
    font-size: 22px;
    border-radius: 8px;
    cursor: pointer;
    touch-action: manipulation;
    user-select: none;
    -webkit-user-select: none;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.1s;
  }

  .game-dpad button:active { background: rgba(255,255,255,0.25); }

  .dpad-up { top: 0; left: 54px; }
  .dpad-down { bottom: 0; left: 54px; }
  .dpad-left { top: 54px; left: 0; }
  .dpad-right { top: 54px; right: 0; }
  .dpad-action {
    top: 54px;
    left: 54px;
    font-size: 11px !important;
    font-weight: bold;
    letter-spacing: 0.5px;
  }

  .game-hud {
    position: absolute;
    top: 8px;
    left: 12px;
    color: #fff;
    font-family: 'Courier New', monospace;
    font-size: 13px;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    pointer-events: none;
    z-index: 5;
  }

  .game-hud .star-count { color: #ffd740; }
  .game-hud .npc-count { color: #7ce87c; }

  .game-toast {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.85);
    border: 2px solid #ffd740;
    border-radius: 10px;
    padding: 16px 24px;
    color: #fff;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    text-align: center;
    max-width: 320px;
    z-index: 6;
    animation: toastIn 0.3s ease;
  }

  .game-toast.active { display: block; }

  .game-toast .toast-star { color: #ffd740; font-size: 20px; }

  @keyframes toastIn {
    from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
    to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
  }

  @media (pointer: coarse) {
    .game-dpad { display: block; }
  }

  @media (max-width: 680px) {
    #gameCanvas { width: 100%; height: auto; }
    .game-dpad { display: block; }
  }
</style>
</head>
<body>

<div class="header">
  <h1>Job Comparison Tool</h1>
  <div class="header-actions">
    <label class="partner-toggle">
      <input type="checkbox" id="partnerToggle" checked>
      Partner Categories
    </label>
    <button class="btn btn-break" id="breakBtn">Take a Break</button>
    <button class="btn btn-primary" id="addJobBtn">+ Add Job</button>
    <button class="btn" id="exportBtn">Export</button>
    <button class="btn" id="importBtn">Import</button>
    <button class="btn btn-danger" id="resetBtn">Reset All</button>
    <input type="file" id="importFile" accept=".json" class="hidden">
  </div>
</div>

<div class="game-container" id="gameContainer">
  <div class="game-header">
    <span>Arrow keys to move, Space to talk</span>
    <button class="btn-close-game" id="closeGameBtn">Back to Work</button>
  </div>
  <div class="game-canvas-wrapper">
    <canvas id="gameCanvas" width="640" height="400"></canvas>
    <div class="game-hud">
      <div><span class="star-count" id="hudStars">0</span> / <span id="hudStarsTotal">0</span> stars</div>
      <div><span class="npc-count" id="hudNpcs">0</span> / <span id="hudNpcsTotal">0</span> conversations</div>
    </div>
    <div class="game-toast" id="gameToast">
      <div class="toast-star">&#9733;</div>
      <div id="toastText"></div>
    </div>
    <div class="game-dialogue" id="gameDialogue">
      <div class="speaker" id="dialogueSpeaker"></div>
      <div id="dialogueText"></div>
      <div class="prompt-hint">Press Space to continue <span>&#9660;</span></div>
    </div>
  </div>
  <div class="game-dpad" id="gameDpad">
    <button class="dpad-up" data-dir="up">&#9650;</button>
    <button class="dpad-left" data-dir="left">&#9664;</button>
    <button class="dpad-action" data-dir="action">TALK</button>
    <button class="dpad-right" data-dir="right">&#9654;</button>
    <button class="dpad-down" data-dir="down">&#9660;</button>
  </div>
</div>

<div class="summary-bar" id="summaryBar"></div>

<div id="mainContent"></div>

<script>
// ‚îÄ‚îÄ Default State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function getDefaultState() {
  return {
    version: 1,
    partnerMode: true,
    showNotes: true,
    groups: [
      {
        id: 'compensation', name: 'Compensation & Financial', color: 'var(--group-compensation)', isPartner: false,
        categories: [
          { id: 'base_salary', name: 'Base Salary', description: 'Annual base compensation', weight: 5, defaultWeight: 5, isCustom: false, hidden: false },
          { id: 'equity', name: 'Equity / Stock', description: 'RSUs, options, equity upside', weight: 3, defaultWeight: 3, isCustom: false, hidden: false },
          { id: 'bonus', name: 'Bonus Potential', description: 'Annual bonus, signing bonus', weight: 3, defaultWeight: 3, isCustom: false, hidden: false },
          { id: 'benefits', name: 'Benefits', description: 'Health, dental, vision insurance quality & cost', weight: 4, defaultWeight: 4, isCustom: false, hidden: false },
          { id: 'retirement', name: 'Retirement / 401k', description: 'Employer match, vesting schedule', weight: 3, defaultWeight: 3, isCustom: false, hidden: false },
          { id: 'col', name: 'Cost of Living', description: 'How far your salary goes in that location', weight: 4, defaultWeight: 4, isCustom: false, hidden: false },
        ]
      },
      {
        id: 'career', name: 'Career & Growth', color: 'var(--group-career)', isPartner: false,
        categories: [
          { id: 'growth', name: 'Growth Trajectory', description: 'Promotion path, title progression', weight: 4, defaultWeight: 4, isCustom: false, hidden: false },
          { id: 'learning', name: 'Learning & Development', description: 'Mentorship, training budget, skill growth', weight: 3, defaultWeight: 3, isCustom: false, hidden: false },
          { id: 'institution', name: 'Institutional Support', description: 'Research infrastructure, grant support, lab space, funding culture', weight: 4, defaultWeight: 4, isCustom: false, hidden: false },
          { id: 'patient_pop', name: 'Patient Population Access', description: 'Pediatric patient volume and diversity for research recruitment', weight: 4, defaultWeight: 4, isCustom: false, hidden: false },
          { id: 'physician_collab', name: 'Physician Collaborators', description: 'Pediatricians, child psychiatrists, and other MDs available to collaborate with', weight: 3, defaultWeight: 3, isCustom: false, hidden: false },
          { id: 'faculty', name: 'Research Faculty & Mentors', description: 'Strength of psych department, senior researchers, mentorship opportunities', weight: 3, defaultWeight: 3, isCustom: false, hidden: false },
          { id: 'reputation', name: 'Institution Reputation', description: 'Academic prestige, research output, industry standing', weight: 3, defaultWeight: 3, isCustom: false, hidden: false },
          { id: 'stability', name: 'Organization Stability', description: 'Financial health, layoff risk, funding outlook', weight: 3, defaultWeight: 3, isCustom: false, hidden: false },
          { id: 'team', name: 'Team & Manager', description: 'Quality of team, manager/PI impression from interviews', weight: 4, defaultWeight: 4, isCustom: false, hidden: false },
          { id: 'role_fit', name: 'Role Alignment', description: 'How well the work matches your research interests', weight: 4, defaultWeight: 4, isCustom: false, hidden: false },
        ]
      },
      {
        id: 'worklife', name: 'Work-Life & Flexibility', color: 'var(--group-worklife)', isPartner: false,
        categories: [
          { id: 'wlb', name: 'Work-Life Balance', description: 'Expected hours, on-call, crunch culture', weight: 4, defaultWeight: 4, isCustom: false, hidden: false },
          { id: 'remote', name: 'Remote / Hybrid Flexibility', description: 'WFH policy, async culture', weight: 4, defaultWeight: 4, isCustom: false, hidden: false },
          { id: 'pto', name: 'PTO & Leave', description: 'Vacation days, parental leave, sick leave', weight: 3, defaultWeight: 3, isCustom: false, hidden: false },
          { id: 'commute', name: 'Commute', description: 'Time, cost, stress of getting to office', weight: 3, defaultWeight: 3, isCustom: false, hidden: false },
        ]
      },
      {
        id: 'location', name: 'Location & Lifestyle', color: 'var(--group-location)', isPartner: false,
        categories: [
          { id: 'loc_quality', name: 'Location Quality', description: 'City amenities, climate, things to do', weight: 3, defaultWeight: 3, isCustom: false, hidden: false },
          { id: 'proximity', name: 'Proximity to Family / Friends', description: 'Distance from people who matter', weight: 2, defaultWeight: 2, isCustom: false, hidden: false },
          { id: 'housing', name: 'Housing Market', description: 'Ability to buy or rent comfortably', weight: 3, defaultWeight: 3, isCustom: false, hidden: false },
        ]
      },
      {
        id: 'partner', name: 'Partner Considerations', color: 'var(--group-partner)', isPartner: true,
        categories: [
          { id: 'partner_jobs', name: "Partner's Job Market", description: "Availability of good roles for partner in that area", weight: 3, defaultWeight: 3, isCustom: false, hidden: false },
          { id: 'partner_pref', name: "Partner's Location Preference", description: 'How much partner wants to live there overall', weight: 3, defaultWeight: 3, isCustom: false, hidden: false },
          { id: 'partner_career', name: "Partner's Career Impact", description: "Effect on partner's career trajectory", weight: 2, defaultWeight: 2, isCustom: false, hidden: false },
          { id: 'partner_social', name: 'Social / Community Fit', description: "Partner's existing network, community opportunities", weight: 2, defaultWeight: 2, isCustom: false, hidden: false },
        ]
      },
    ],
    jobs: []
  };
}

// ‚îÄ‚îÄ State Management ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const STORAGE_KEY = 'job_comparison_tool_state';
let state;

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) {
      const parsed = JSON.parse(raw);
      if (parsed && parsed.version === 1) {
        state = parsed;
        return;
      }
    }
  } catch (e) { /* ignore parse errors */ }
  state = getDefaultState();
}

let saveTimeout;
function saveState() {
  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(() => {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch (e) {
      console.warn('Could not save to localStorage:', e);
    }
  }, 200);
}

// ‚îÄ‚îÄ Calculation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function getVisibleCategories() {
  const cats = [];
  for (const g of state.groups) {
    if (g.isPartner && !state.partnerMode) continue;
    for (const c of g.categories) {
      if (!c.hidden) cats.push(c);
    }
  }
  return cats;
}

function calculateWeightedScore(job) {
  let weightedSum = 0;
  let weightSum = 0;
  let scored = 0;
  const visibleCats = getVisibleCategories();

  for (const cat of visibleCats) {
    const score = job.scores[cat.id];
    if (score != null) {
      weightedSum += score * cat.weight;
      weightSum += 10 * cat.weight;
      scored++;
    }
  }

  if (weightSum === 0) return { score: null, scored, total: visibleCats.length };
  return {
    score: (weightedSum / weightSum) * 10,
    scored,
    total: visibleCats.length
  };
}

function calculateGroupScore(job, group) {
  let weightedSum = 0;
  let weightSum = 0;

  for (const cat of group.categories) {
    if (cat.hidden) continue;
    const score = job.scores[cat.id];
    if (score != null) {
      weightedSum += score * cat.weight;
      weightSum += 10 * cat.weight;
    }
  }

  if (weightSum === 0) return null;
  return (weightedSum / weightSum) * 10;
}

// ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function sanitize(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function getCellColor(score) {
  if (score == null) return 'transparent';
  const hue = (score - 1) * (120 / 9); // 0 (red) to 120 (green)
  return `hsl(${hue}, 42%, 88%)`;
}

function getRowExtremes(catId) {
  let best = null, worst = null, bestVal = -1, worstVal = 11;
  let count = 0;
  for (const job of state.jobs) {
    const s = job.scores[catId];
    if (s != null) {
      count++;
      if (s > bestVal) { bestVal = s; best = job.id; }
      if (s < worstVal) { worstVal = s; worst = job.id; }
    }
  }
  if (count < 2) return { best: null, worst: null };
  if (bestVal === worstVal) return { best: null, worst: null };
  return { best, worst };
}

function nextId() {
  return 'job_' + Date.now() + '_' + Math.random().toString(36).slice(2, 6);
}

function nextCatId() {
  return 'custom_' + Date.now() + '_' + Math.random().toString(36).slice(2, 6);
}

// ‚îÄ‚îÄ Actions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function addJob() {
  state.jobs.push({
    id: nextId(),
    name: 'Job ' + (state.jobs.length + 1),
    notes: '',
    scores: {}
  });
  saveState();
  render();
}

function removeJob(jobId) {
  state.jobs = state.jobs.filter(j => j.id !== jobId);
  saveState();
  render();
}

function updateScore(jobId, catId, value) {
  const job = state.jobs.find(j => j.id === jobId);
  if (!job) return;
  if (value === '' || value == null) {
    delete job.scores[catId];
  } else {
    const num = Math.min(10, Math.max(1, parseInt(value)));
    if (!isNaN(num)) job.scores[catId] = num;
  }
  saveState();
  updateDisplayInPlace();
}

function updateWeight(catId, value) {
  for (const g of state.groups) {
    for (const c of g.categories) {
      if (c.id === catId) {
        c.weight = Math.min(5, Math.max(1, parseInt(value)));
        saveState();
        updateDisplayInPlace();
        return;
      }
    }
  }
}

function updateJobName(jobId, name) {
  const job = state.jobs.find(j => j.id === jobId);
  if (job) { job.name = name; saveState(); renderSummary(); }
}

function updateJobNotes(jobId, notes) {
  const job = state.jobs.find(j => j.id === jobId);
  if (job) { job.notes = notes; saveState(); }
}

function togglePartnerMode() {
  state.partnerMode = !state.partnerMode;
  saveState();
  render();
}

function addCustomCategory(groupId) {
  const name = prompt('Category name:');
  if (!name || !name.trim()) return;
  const desc = prompt('Description (optional):') || '';
  const group = state.groups.find(g => g.id === groupId);
  if (!group) return;
  group.categories.push({
    id: nextCatId(),
    name: name.trim(),
    description: desc.trim(),
    weight: 3,
    defaultWeight: 3,
    isCustom: true,
    hidden: false
  });
  saveState();
  render();
}

function removeCategory(catId) {
  for (const g of state.groups) {
    const idx = g.categories.findIndex(c => c.id === catId);
    if (idx !== -1) {
      if (g.categories[idx].isCustom) {
        g.categories.splice(idx, 1);
      } else {
        g.categories[idx].hidden = true;
      }
      // Clean up scores
      for (const job of state.jobs) delete job.scores[catId];
      saveState();
      render();
      return;
    }
  }
}

function resetWeights() {
  for (const g of state.groups) {
    for (const c of g.categories) {
      c.weight = c.defaultWeight;
    }
  }
  saveState();
  render();
}

function resetAll() {
  if (!confirm('Reset everything? All jobs and scores will be lost.')) return;
  localStorage.removeItem(STORAGE_KEY);
  state = getDefaultState();
  render();
}

function exportData() {
  const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'job-comparison-' + new Date().toISOString().slice(0, 10) + '.json';
  a.click();
  URL.revokeObjectURL(url);
}

function importData() {
  document.getElementById('importFile').click();
}

function handleImport(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(ev) {
    try {
      const data = JSON.parse(ev.target.result);
      if (!data.version || !data.groups || !data.jobs) {
        alert('Invalid file format.');
        return;
      }
      state = data;
      saveState();
      render();
    } catch (err) {
      alert('Could not parse file: ' + err.message);
    }
  };
  reader.readAsText(file);
  e.target.value = '';
}

// ‚îÄ‚îÄ In-place Update (no DOM rebuild) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function updateDisplayInPlace() {
  // Update score cell backgrounds and best/worst borders
  const allScoreCells = document.querySelectorAll('.score-cell');
  for (const cell of allScoreCells) {
    const input = cell.querySelector('.score-input');
    if (!input) continue;
    const jobId = input.dataset.jobId;
    const catId = input.dataset.catId;
    const job = state.jobs.find(j => j.id === jobId);
    const score = job ? job.scores[catId] : null;
    cell.style.background = getCellColor(score);
  }

  // Update best/worst borders per category row
  const catIds = new Set();
  for (const g of state.groups) {
    if (g.isPartner && !state.partnerMode) continue;
    for (const c of g.categories) {
      if (!c.hidden) catIds.add(c.id);
    }
  }

  for (const catId of catIds) {
    const extremes = getRowExtremes(catId);
    const cells = document.querySelectorAll(`.score-input[data-cat-id="${catId}"]`);
    for (const input of cells) {
      const cell = input.closest('.score-cell');
      cell.classList.remove('best-in-row', 'worst-in-row');
      if (extremes.best === input.dataset.jobId) cell.classList.add('best-in-row');
      else if (extremes.worst === input.dataset.jobId) cell.classList.add('worst-in-row');
    }
  }

  // Update weight dots
  const allWeightDots = document.querySelectorAll('.weight-dots');
  for (const container of allWeightDots) {
    const catId = container.dataset.catId;
    let weight = 3;
    for (const g of state.groups) {
      for (const c of g.categories) {
        if (c.id === catId) { weight = c.weight; break; }
      }
    }
    const dots = container.querySelectorAll('.weight-dot');
    dots.forEach((dot, i) => {
      dot.classList.toggle('filled', i < weight);
    });
  }

  // Update group subtotals
  const subtotalCells = document.querySelectorAll('.subtotal-score');
  let subtotalIdx = 0;
  for (const group of state.groups) {
    if (group.isPartner && !state.partnerMode) continue;
    for (const job of state.jobs) {
      const gs = calculateGroupScore(job, group);
      if (subtotalCells[subtotalIdx]) {
        subtotalCells[subtotalIdx].textContent = gs != null ? gs.toFixed(1) : '--';
      }
      subtotalIdx++;
    }
  }

  // Update overall totals
  const totalCells = document.querySelectorAll('.total-score');
  state.jobs.forEach((job, i) => {
    const result = calculateWeightedScore(job);
    if (totalCells[i]) {
      totalCells[i].textContent = result.score != null ? result.score.toFixed(1) : '--';
    }
  });

  // Update summary bar
  renderSummary();
}

// ‚îÄ‚îÄ Render ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function renderSummary() {
  const bar = document.getElementById('summaryBar');
  if (state.jobs.length === 0) {
    bar.innerHTML = '';
    return;
  }

  const scored = state.jobs.map(job => {
    const result = calculateWeightedScore(job);
    return { job, ...result };
  }).sort((a, b) => (b.score ?? -1) - (a.score ?? -1));

  let rank = 0;
  bar.innerHTML = scored.map((item, i) => {
    if (item.score != null) rank = i + 1;
    const rankClass = rank <= 3 && item.score != null ? `rank-${rank}` : '';
    const badge = rank <= 3 && item.score != null ? `<div class="rank-badge">${rank}</div>` : '';
    const scoreDisplay = item.score != null ? item.score.toFixed(1) : '--';
    return `
      <div class="summary-card ${rankClass}">
        ${badge}
        <div class="summary-name" title="${sanitize(item.job.name)}">${sanitize(item.job.name)}</div>
        <div class="summary-score">${scoreDisplay}</div>
        <div class="summary-completeness">${item.scored} / ${item.total} scored</div>
      </div>
    `;
  }).join('');
}

function renderGrid() {
  const main = document.getElementById('mainContent');

  if (state.jobs.length === 0) {
    main.innerHTML = `
      <div class="empty-state">
        <h2>No jobs to compare yet</h2>
        <p>Add your first job opportunity to get started.</p>
        <button class="btn btn-primary" onclick="addJob()">+ Add Your First Job</button>
      </div>
    `;
    return;
  }

  const jobs = state.jobs;
  let html = '<div class="grid-wrapper"><table class="grid">';

  // Header row
  html += '<thead><tr>';
  html += '<th class="col-category">Category</th>';
  html += '<th class="col-weight">Weight</th>';
  for (const job of jobs) {
    html += `<th class="col-job job-header">
      <input class="job-name-input" value="${sanitize(job.name)}" maxlength="40"
        data-job-id="${job.id}" data-action="rename">
      <div class="job-header-actions">
        <button class="btn-icon" title="Toggle notes" data-action="toggle-notes" data-job-id="${job.id}">üìù</button>
        <button class="btn-icon danger" title="Remove job" data-action="remove-job" data-job-id="${job.id}">‚úï</button>
      </div>
    </th>`;
  }
  html += '</tr></thead><tbody>';

  // Notes row
  html += '<tr class="notes-row">';
  html += '<td class="col-category" style="font-size:12px;color:var(--color-text-secondary)">Notes</td>';
  html += '<td class="col-weight"></td>';
  for (const job of jobs) {
    html += `<td class="col-job">
      <textarea class="notes-textarea" placeholder="Notes..." data-job-id="${job.id}" data-action="notes">${sanitize(job.notes)}</textarea>
    </td>`;
  }
  html += '</tr>';

  // Groups and categories
  for (const group of state.groups) {
    if (group.isPartner && !state.partnerMode) continue;

    // Group header
    html += `<tr class="group-header"><td class="col-category" style="background:${group.color}">${group.isPartner ? 'üë• ' : ''}${sanitize(group.name)}</td>`;
    html += `<td class="col-weight" style="background:${group.color}"></td>`;
    for (const job of jobs) {
      html += `<td class="col-job" style="background:${group.color}"></td>`;
    }
    html += '</tr>';

    // Category rows
    const visibleCats = group.categories.filter(c => !c.hidden);
    for (const cat of visibleCats) {
      const extremes = getRowExtremes(cat.id);
      html += '<tr>';
      html += `<td class="col-category">
        <div class="cat-name">
          <span>${sanitize(cat.name)}</span>
          ${cat.description ? `<span class="info-icon" data-tooltip="${sanitize(cat.description)}">i</span>` : ''}
          <button class="btn-icon danger" style="width:18px;height:18px;font-size:11px;" title="${cat.isCustom ? 'Remove' : 'Hide'}" data-action="remove-cat" data-cat-id="${cat.id}">‚úï</button>
        </div>
      </td>`;
      html += `<td class="col-weight">
        <div class="weight-dots" data-cat-id="${cat.id}" data-action="weight">
          ${[1,2,3,4,5].map(w => `<div class="weight-dot${w <= cat.weight ? ' filled' : ''}" data-weight="${w}"></div>`).join('')}
        </div>
      </td>`;

      for (const job of jobs) {
        const score = job.scores[cat.id];
        const bg = getCellColor(score);
        let cls = 'col-job score-cell';
        if (extremes.best === job.id) cls += ' best-in-row';
        else if (extremes.worst === job.id) cls += ' worst-in-row';

        html += `<td class="${cls}" style="background:${bg}">
          <input class="score-input" type="number" min="1" max="10" placeholder="-"
            value="${score != null ? score : ''}"
            data-job-id="${job.id}" data-cat-id="${cat.id}" data-action="score">
        </td>`;
      }
      html += '</tr>';
    }

    // Add category button
    html += `<tr><td class="col-category" style="padding:4px 12px;">
      <button class="add-category-btn" data-action="add-cat" data-group-id="${group.id}">+ Add category</button>
    </td><td class="col-weight"></td>`;
    for (const job of jobs) html += '<td class="col-job"></td>';
    html += '</tr>';

    // Group subtotal
    html += '<tr class="subtotal-row">';
    html += `<td class="col-category" style="background:${group.color}">${sanitize(group.name)} Subtotal</td>`;
    html += `<td class="col-weight" style="background:${group.color}"></td>`;
    for (const job of jobs) {
      const gs = calculateGroupScore(job, group);
      html += `<td class="col-job" style="background:${group.color}"><span class="subtotal-score">${gs != null ? gs.toFixed(1) : '--'}</span></td>`;
    }
    html += '</tr>';
  }

  // Total row
  html += '<tr class="total-row">';
  html += '<td class="col-category">Overall Score</td>';
  html += '<td class="col-weight"><button class="add-category-btn" onclick="resetWeights()" style="font-size:11px;">Reset weights</button></td>';
  for (const job of jobs) {
    const result = calculateWeightedScore(job);
    html += `<td class="col-job"><span class="total-score">${result.score != null ? result.score.toFixed(1) : '--'}</span></td>`;
  }
  html += '</tr>';

  html += '</tbody></table></div>';
  main.innerHTML = html;
}

function render() {
  document.getElementById('partnerToggle').checked = state.partnerMode;
  renderSummary();
  renderGrid();
}

// ‚îÄ‚îÄ Event Delegation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

document.addEventListener('input', function(e) {
  const el = e.target;
  const action = el.dataset.action;

  if (action === 'score') {
    updateScore(el.dataset.jobId, el.dataset.catId, el.value);
  } else if (action === 'rename') {
    updateJobName(el.dataset.jobId, el.value);
  } else if (action === 'notes') {
    updateJobNotes(el.dataset.jobId, el.value);
  }
});

document.addEventListener('click', function(e) {
  const el = e.target;

  // Weight dots
  if (el.classList.contains('weight-dot')) {
    updateWeight(el.parentElement.dataset.catId, el.dataset.weight);
    return;
  }

  const action = el.dataset.action || el.closest('[data-action]')?.dataset.action;
  const target = el.closest('[data-action]');

  if (action === 'remove-job') {
    if (confirm('Remove this job?')) {
      removeJob(target.dataset.jobId);
    }
  } else if (action === 'remove-cat') {
    removeCategory(target.dataset.catId);
  } else if (action === 'add-cat') {
    addCustomCategory(target.dataset.groupId);
  }
});

// Header buttons
document.getElementById('addJobBtn').addEventListener('click', addJob);
document.getElementById('exportBtn').addEventListener('click', exportData);
document.getElementById('importBtn').addEventListener('click', importData);
document.getElementById('resetBtn').addEventListener('click', resetAll);
document.getElementById('partnerToggle').addEventListener('change', togglePartnerMode);
document.getElementById('importFile').addEventListener('change', handleImport);

// ‚îÄ‚îÄ Init ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

loadState();
render();

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚îÄ‚îÄ TAKE A BREAK GAME ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

(function() {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const TILE = 32;

  // Map dimensions (bigger world)
  const MAP_COLS = 40, MAP_ROWS = 30;

  let gameActive = false;
  let animFrame = null;
  let tick = 0;

  // Camera
  let camX = 0, camY = 0;

  // Player
  const player = { x: 20, y: 15, dir: 0, moving: false };
  const keys = {};

  // Dialogue
  let dialogueQueue = [];
  let dialogueActive = false;
  let typewriterText = '';
  let typewriterIdx = 0;
  let typewriterTimer = 0;

  // Toast
  let toastTimer = 0;

  // Stars collected
  let starsCollected = 0;
  let npcstalked = 0;

  // Fog overlay canvas
  const fogCanvas = document.createElement('canvas');
  fogCanvas.width = W;
  fogCanvas.height = H;
  const fogCtx = fogCanvas.getContext('2d');

  // ‚îÄ‚îÄ NPCs ‚îÄ‚îÄ

  const npcs = [
    {
      x: 8, y: 5, color: '#e06070', name: 'Sage', talked: false,
      lines: [
        "Hey there! Take a deep breath.",
        "What's one small thing that brought you joy today?",
        "Even tiny moments matter. Hold onto that feeling."
      ]
    },
    {
      x: 32, y: 5, color: '#6090e0', name: 'River', talked: false,
      lines: [
        "The water here is so peaceful.",
        "If you could do anything tomorrow with no obligations, what would it be?",
        "That answer says a lot about what really matters to you."
      ]
    },
    {
      x: 6, y: 22, color: '#e0a030', name: 'Ember', talked: false,
      lines: [
        "I've been thinking...",
        "When was the last time you lost track of time doing something you loved?",
        "Chase that feeling. It's trying to tell you something."
      ]
    },
    {
      x: 34, y: 23, color: '#50b880', name: 'Fern', talked: false,
      lines: [
        "Oh hi! Quick question.",
        "Who's someone that makes you feel like the best version of yourself?",
        "Keep those people close. They're worth more than any job title."
      ]
    },
    {
      x: 20, y: 4, color: '#b070d0', name: 'Luna', talked: false,
      lines: [
        "The view from up here is incredible.",
        "What would you want your life to look like in 5 years... not your career, your LIFE?",
        "Sometimes we optimize for the wrong things. Don't forget to optimize for happiness."
      ]
    },
    {
      x: 20, y: 25, color: '#d09050', name: 'Oak', talked: false,
      lines: [
        "I like sitting by this old tree.",
        "What's one thing you'd never want to give up, no matter how good the offer?",
        "That's your non-negotiable. Protect it fiercely."
      ]
    },
  ];

  // ‚îÄ‚îÄ Stars (collectibles) ‚îÄ‚îÄ

  const starPrompts = [
    "Name one thing you're grateful for right now.",
    "What made you smile this week?",
    "Think of someone who believes in you.",
    "What's a place that makes you feel at peace?",
    "What's a skill you're proud of having?",
    "Name a moment that made you laugh recently.",
    "What's something beautiful you noticed today?",
    "Think of a time you overcame something hard.",
    "What's a simple pleasure you never get tired of?",
    "Who would you call if you had great news?",
    "What's something you're looking forward to?",
    "Name a quality about yourself that you like.",
    "What song always lifts your mood?",
    "What's a memory that always makes you feel warm?",
    "What would you do with a free afternoon?",
  ];

  const stars = [];

  function placeStars() {
    stars.length = 0;
    const positions = [
      [5,10],[12,3],[25,7],[35,10],[15,18],[30,18],
      [8,26],[18,22],[28,26],[37,15],[10,14],[22,10],
      [33,3],[14,27],[26,20]
    ];
    positions.forEach((pos, i) => {
      stars.push({ x: pos[0], y: pos[1], collected: false, prompt: starPrompts[i] });
    });
  }

  // ‚îÄ‚îÄ Map ‚îÄ‚îÄ

  const map = [];

  function getBiome(x, y) {
    // Center is meadow/paths, corners are biomes
    const cx = MAP_COLS / 2, cy = MAP_ROWS / 2;
    const dx = x - cx, dy = y - cy;
    if (Math.abs(dx) < 5 && Math.abs(dy) < 4) return 'meadow';
    if (x < 14 && y < 12) return 'forest';
    if (x > 26 && y < 12) return 'lake';
    if (x < 14 && y > 18) return 'garden';
    if (x > 26 && y > 18) return 'mountain';
    return 'meadow';
  }

  function generateMap() {
    const seeded = (x, y, m) => ((x * 7 + y * 13 + m) * 2654435761 >>> 0) % 100;

    for (let y = 0; y < MAP_ROWS; y++) {
      map[y] = [];
      for (let x = 0; x < MAP_COLS; x++) {
        const biome = getBiome(x, y);
        const s = seeded(x, y, 1);

        // Borders are always trees
        if (x === 0 || y === 0 || x === MAP_COLS - 1 || y === MAP_ROWS - 1) {
          map[y][x] = 4; continue;
        }

        // Paths: cross through center
        if ((x === 19 || x === 20) && y > 0 && y < MAP_ROWS - 1) { map[y][x] = 2; continue; }
        if ((y === 14 || y === 15) && x > 0 && x < MAP_COLS - 1) { map[y][x] = 2; continue; }

        if (biome === 'forest') {
          map[y][x] = s < 35 ? 4 : s < 45 ? 1 : 0;
        } else if (biome === 'lake') {
          if (x > 28 && x < 37 && y > 3 && y < 10) map[y][x] = 3;
          else if (s < 10 && x > 27) map[y][x] = 3;
          else map[y][x] = s < 8 ? 5 : s < 15 ? 1 : 0;
        } else if (biome === 'garden') {
          map[y][x] = s < 30 ? 5 : s < 38 ? 1 : 0;
        } else if (biome === 'mountain') {
          map[y][x] = s < 25 ? 6 : s < 40 ? 4 : s < 55 ? 1 : 0;
        } else {
          map[y][x] = s < 10 ? 1 : s < 14 ? 5 : s < 18 ? 4 : 0;
        }
      }
    }

    // Ensure NPC, player, and star positions are walkable
    for (const npc of npcs) map[npc.y][npc.x] = 0;
    for (const star of stars) map[star.y][star.x] = s_walkable(star.x, star.y) ? map[star.y][star.x] : 0;
    map[player.y][player.x] = 2;

    function s_walkable(x, y) {
      const t = map[y]?.[x];
      return t !== undefined && t !== 3 && t !== 4 && t !== 6;
    }
    // Fix star tiles
    for (const star of stars) {
      if (!s_walkable(star.x, star.y)) map[star.y][star.x] = 0;
    }
  }

  function isBlocked(x, y) {
    if (x < 0 || y < 0 || x >= MAP_COLS || y >= MAP_ROWS) return true;
    const t = map[y][x];
    if (t === 3 || t === 4 || t === 6) return true;
    for (const n of npcs) { if (n.x === x && n.y === y) return true; }
    return false;
  }

  // ‚îÄ‚îÄ Drawing ‚îÄ‚îÄ

  const COLORS = {
    grass:     ['#4a8c38','#3d7a2e'],
    darkGrass: ['#3d7a2e','#357026'],
    path:      ['#c8b478','#baa868'],
    water:     ['#3088c0','#2878b0'],
    treeTrunk: '#6b4226',
    flower:    ['#e85080','#e0d040','#60a0e0','#e08030'],
    rock:      '#888',
  };

  function drawTile(x, y) {
    const px = x * TILE - camX, py = y * TILE - camY;
    // Skip if off-screen
    if (px < -TILE || py < -TILE || px > W || py > H) return;

    const t = map[y][x];
    const checker = (x + y) % 2;

    if (t <= 1) {
      ctx.fillStyle = t === 0 ? COLORS.grass[checker] : COLORS.darkGrass[checker];
      ctx.fillRect(px, py, TILE, TILE);
      if ((x * 7 + y * 13) % 5 === 0) {
        ctx.strokeStyle = '#5a9c48';
        ctx.lineWidth = 1;
        const bx = px + (x * 3 % 20) + 6, by = py + (y * 7 % 20) + 8;
        ctx.beginPath(); ctx.moveTo(bx, by + 8); ctx.lineTo(bx - 2, by); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(bx + 4, by + 8); ctx.lineTo(bx + 6, by + 2); ctx.stroke();
      }
    } else if (t === 2) {
      ctx.fillStyle = COLORS.path[checker];
      ctx.fillRect(px, py, TILE, TILE);
      if ((x * 11 + y * 7) % 4 === 0) {
        ctx.fillStyle = '#b09858';
        ctx.fillRect(px + 8, py + 12, 2, 2);
        ctx.fillRect(px + 20, py + 6, 2, 2);
      }
    } else if (t === 3) {
      ctx.fillStyle = COLORS.water[(tick + x + y) % 2 === 0 ? 0 : 1];
      ctx.fillRect(px, py, TILE, TILE);
      const sx = (tick * 3 + x * 17) % 28 + px, sy = (tick * 5 + y * 11) % 24 + py;
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.fillRect(sx, sy, 3, 2);
    } else if (t === 4) {
      ctx.fillStyle = COLORS.grass[checker];
      ctx.fillRect(px, py, TILE, TILE);
      ctx.fillStyle = COLORS.treeTrunk;
      ctx.fillRect(px + 12, py + 18, 8, 14);
      ctx.fillStyle = '#2d6b1e';
      ctx.beginPath(); ctx.arc(px + 16, py + 14, 13, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#3a8828';
      ctx.beginPath(); ctx.arc(px + 14, py + 11, 9, 0, Math.PI * 2); ctx.fill();
    } else if (t === 5) {
      ctx.fillStyle = COLORS.grass[checker];
      ctx.fillRect(px, py, TILE, TILE);
      const fc = COLORS.flower[(x * 3 + y * 7) % 4];
      const sway = Math.sin(tick * 0.1 + x + y) * 1.5;
      ctx.fillStyle = '#4a8c38';
      ctx.fillRect(px + 14, py + 14, 2, 12);
      ctx.fillStyle = fc;
      ctx.beginPath(); ctx.arc(px + 15 + sway, py + 12, 5, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(px + 15 + sway, py + 12, 2, 0, Math.PI * 2); ctx.fill();
    } else if (t === 6) {
      ctx.fillStyle = COLORS.grass[checker];
      ctx.fillRect(px, py, TILE, TILE);
      ctx.fillStyle = COLORS.rock;
      ctx.beginPath(); ctx.ellipse(px + 16, py + 20, 12, 8, 0, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#999';
      ctx.beginPath(); ctx.ellipse(px + 14, py + 17, 8, 5, -0.3, 0, Math.PI * 2); ctx.fill();
    }
  }

  function drawStar(star) {
    if (star.collected) return;
    const px = star.x * TILE - camX + 16, py = star.y * TILE - camY + 16;
    if (px < -20 || py < -20 || px > W + 20 || py > H + 20) return;
    const pulse = Math.sin(tick * 0.08 + star.x) * 3 + 10;
    const glow = Math.sin(tick * 0.06 + star.y) * 0.3 + 0.5;
    // Glow
    ctx.fillStyle = `rgba(255, 215, 64, ${glow * 0.3})`;
    ctx.beginPath(); ctx.arc(px, py, pulse + 4, 0, Math.PI * 2); ctx.fill();
    // Star shape
    ctx.fillStyle = '#ffd740';
    ctx.save();
    ctx.translate(px, py);
    ctx.rotate(tick * 0.02);
    drawStarShape(ctx, 0, 0, 5, pulse * 0.6, pulse * 0.3);
    ctx.restore();
  }

  function drawStarShape(c, cx, cy, spikes, outerR, innerR) {
    let rot = Math.PI / 2 * 3;
    const step = Math.PI / spikes;
    c.beginPath();
    c.moveTo(cx, cy - outerR);
    for (let i = 0; i < spikes; i++) {
      c.lineTo(cx + Math.cos(rot) * outerR, cy + Math.sin(rot) * outerR);
      rot += step;
      c.lineTo(cx + Math.cos(rot) * innerR, cy + Math.sin(rot) * innerR);
      rot += step;
    }
    c.closePath();
    c.fill();
  }

  function drawSprite(x, y, dir, frame, color) {
    const px = x * TILE - camX, py = y * TILE - camY;
    if (px < -TILE * 2 || py < -TILE * 2 || px > W + TILE || py > H + TILE) return;
    const bounce = Math.sin(frame * 0.5) * 1.5;

    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.beginPath(); ctx.ellipse(px + 16, py + 30, 10, 4, 0, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = color;
    ctx.fillRect(px + 8, py + 12 + bounce, 16, 14);

    ctx.fillStyle = '#fdd';
    ctx.beginPath(); ctx.arc(px + 16, py + 10 + bounce, 9, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = '#333';
    if (dir === 3) { /* up */ }
    else if (dir === 1) { ctx.fillRect(px + 11, py + 8 + bounce, 3, 3); }
    else if (dir === 2) { ctx.fillRect(px + 18, py + 8 + bounce, 3, 3); }
    else { ctx.fillRect(px + 12, py + 8 + bounce, 3, 3); ctx.fillRect(px + 18, py + 8 + bounce, 3, 3); }

    ctx.fillStyle = '#555';
    const step = Math.sin(frame * 0.6) * 3;
    ctx.fillRect(px + 9 + step, py + 26 + bounce, 6, 4);
    ctx.fillRect(px + 17 - step, py + 26 + bounce, 6, 4);
  }

  function drawNPC(npc) {
    drawSprite(npc.x, npc.y, 0, tick * 0.02, npc.color);
    const px = npc.x * TILE - camX, py = npc.y * TILE - camY;
    if (px < -TILE || px > W + TILE) return;

    // Name tag
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    const tw = ctx.measureText(npc.name).width;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(px + 16 - tw / 2 - 3, py - 2, tw + 6, 14);
    ctx.fillStyle = npc.talked ? '#7ce87c' : '#fff';
    ctx.fillText(npc.name, px + 16, py + 8);
    if (npc.talked) {
      ctx.fillText('‚úì', px + 16 + tw / 2 + 6, py + 8);
    }
    ctx.textAlign = 'left';

    // Exclamation mark
    const dist = Math.abs(player.x - npc.x) + Math.abs(player.y - npc.y);
    if (dist <= 2 && !dialogueActive) {
      const bob = Math.sin(tick * 0.08) * 3;
      ctx.fillStyle = npc.talked ? '#7ce87c' : '#ffd740';
      ctx.font = 'bold 16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(npc.talked ? '...' : '!', px + 16, py - 8 + bob);
      ctx.textAlign = 'left';
    }
  }

  function drawPlayer() {
    drawSprite(player.x, player.y, player.dir, player.moving ? tick * 0.15 : 0, '#4488cc');
  }

  // ‚îÄ‚îÄ Fog of Color (world comes alive) ‚îÄ‚îÄ

  function drawFog() {
    const talkedCount = npcs.filter(n => n.talked).length;
    if (talkedCount >= npcs.length) return; // full color, no fog

    fogCtx.clearRect(0, 0, W, H);

    // Dark desaturating overlay
    const fogAlpha = 0.55 - (talkedCount * 0.05);
    fogCtx.fillStyle = `rgba(20, 20, 40, ${Math.max(0.1, fogAlpha)})`;
    fogCtx.fillRect(0, 0, W, H);

    // Punch bright holes around talked NPCs
    fogCtx.globalCompositeOperation = 'destination-out';

    // Player always has a small bright area
    const psx = player.x * TILE - camX + 16;
    const psy = player.y * TILE - camY + 16;
    const pGrad = fogCtx.createRadialGradient(psx, psy, 0, psx, psy, 100);
    pGrad.addColorStop(0, 'rgba(0,0,0,1)');
    pGrad.addColorStop(0.5, 'rgba(0,0,0,0.6)');
    pGrad.addColorStop(1, 'rgba(0,0,0,0)');
    fogCtx.fillStyle = pGrad;
    fogCtx.beginPath(); fogCtx.arc(psx, psy, 100, 0, Math.PI * 2); fogCtx.fill();

    // Each talked NPC blooms color
    for (const npc of npcs) {
      if (!npc.talked) continue;
      const nx = npc.x * TILE - camX + 16;
      const ny = npc.y * TILE - camY + 16;
      const radius = 200;
      const grad = fogCtx.createRadialGradient(nx, ny, 0, nx, ny, radius);
      grad.addColorStop(0, 'rgba(0,0,0,1)');
      grad.addColorStop(0.6, 'rgba(0,0,0,0.8)');
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      fogCtx.fillStyle = grad;
      fogCtx.beginPath(); fogCtx.arc(nx, ny, radius, 0, Math.PI * 2); fogCtx.fill();
    }

    fogCtx.globalCompositeOperation = 'source-over';

    // Draw fog on main canvas
    ctx.drawImage(fogCanvas, 0, 0);
  }

  // ‚îÄ‚îÄ Dialogue ‚îÄ‚îÄ

  function showDialogue(npc) {
    if (!npc.talked) {
      npc.talked = true;
      npcstalked++;
      updateHUD();
    }
    dialogueQueue = npc.lines.map(line => ({ speaker: npc.name, text: line }));
    nextDialogueLine();
  }

  function nextDialogueLine() {
    if (dialogueQueue.length === 0) {
      dialogueActive = false;
      document.getElementById('gameDialogue').classList.remove('active');
      return;
    }
    dialogueActive = true;
    const line = dialogueQueue.shift();
    document.getElementById('dialogueSpeaker').textContent = line.speaker;
    document.getElementById('dialogueText').textContent = '';
    document.getElementById('gameDialogue').classList.add('active');
    typewriterText = line.text;
    typewriterIdx = 0;
    typewriterTimer = 0;
  }

  // ‚îÄ‚îÄ Toast (star pickup) ‚îÄ‚îÄ

  function showToast(text) {
    document.getElementById('toastText').textContent = text;
    document.getElementById('gameToast').classList.add('active');
    toastTimer = 180; // ~3 seconds at 60fps
  }

  function hideToast() {
    document.getElementById('gameToast').classList.remove('active');
  }

  // ‚îÄ‚îÄ HUD ‚îÄ‚îÄ

  function updateHUD() {
    document.getElementById('hudStars').textContent = starsCollected;
    document.getElementById('hudStarsTotal').textContent = stars.length;
    document.getElementById('hudNpcs').textContent = npcstalked;
    document.getElementById('hudNpcsTotal').textContent = npcs.length;
  }

  // ‚îÄ‚îÄ Camera ‚îÄ‚îÄ

  function updateCamera() {
    const targetX = player.x * TILE + TILE / 2 - W / 2;
    const targetY = player.y * TILE + TILE / 2 - H / 2;
    // Smooth follow
    camX += (targetX - camX) * 0.15;
    camY += (targetY - camY) * 0.15;
    // Clamp
    camX = Math.max(0, Math.min(MAP_COLS * TILE - W, camX));
    camY = Math.max(0, Math.min(MAP_ROWS * TILE - H, camY));
  }

  // ‚îÄ‚îÄ Update ‚îÄ‚îÄ

  let moveTimer = 0;
  const MOVE_DELAY = 7;

  function checkStarPickup() {
    for (const star of stars) {
      if (!star.collected && star.x === player.x && star.y === player.y) {
        star.collected = true;
        starsCollected++;
        updateHUD();
        showToast(star.prompt);
      }
    }
  }

  function update() {
    tick++;

    // Toast timer
    if (toastTimer > 0) {
      toastTimer--;
      if (toastTimer === 0) hideToast();
    }

    // Typewriter
    if (dialogueActive && typewriterIdx < typewriterText.length) {
      typewriterTimer++;
      if (typewriterTimer % 2 === 0) {
        typewriterIdx++;
        document.getElementById('dialogueText').textContent = typewriterText.slice(0, typewriterIdx);
      }
    }

    if (dialogueActive) return;

    // Movement
    moveTimer++;
    if (moveTimer >= MOVE_DELAY) {
      let dx = 0, dy = 0;
      if (keys['ArrowLeft'] || keys['a'])  { dx = -1; player.dir = 1; }
      else if (keys['ArrowRight'] || keys['d']) { dx = 1; player.dir = 2; }
      else if (keys['ArrowUp'] || keys['w'])    { dy = -1; player.dir = 3; }
      else if (keys['ArrowDown'] || keys['s'])  { dy = 1; player.dir = 0; }

      if (dx !== 0 || dy !== 0) {
        const nx = player.x + dx, ny = player.y + dy;
        if (!isBlocked(nx, ny)) {
          player.x = nx;
          player.y = ny;
          moveTimer = 0;
          checkStarPickup();
        }
        player.moving = true;
      } else {
        player.moving = false;
      }
    }

    updateCamera();
  }

  // ‚îÄ‚îÄ Draw ‚îÄ‚îÄ

  function draw() {
    ctx.clearRect(0, 0, W, H);
    // Background fill
    ctx.fillStyle = '#2d5a27';
    ctx.fillRect(0, 0, W, H);

    // Visible tile range
    const startCol = Math.max(0, Math.floor(camX / TILE));
    const endCol = Math.min(MAP_COLS - 1, Math.ceil((camX + W) / TILE));
    const startRow = Math.max(0, Math.floor(camY / TILE));
    const endRow = Math.min(MAP_ROWS - 1, Math.ceil((camY + H) / TILE));

    // Tiles
    for (let y = startRow; y <= endRow; y++) {
      for (let x = startCol; x <= endCol; x++) {
        drawTile(x, y);
      }
    }

    // Stars
    for (const star of stars) drawStar(star);

    // NPCs and player sorted by Y for depth
    const entities = [...npcs.map(n => ({type:'npc', y: n.y, data: n})), {type:'player', y: player.y}];
    entities.sort((a, b) => a.y - b.y);
    for (const e of entities) {
      if (e.type === 'player') drawPlayer();
      else drawNPC(e.data);
    }

    // Fog overlay (world comes alive)
    drawFog();
  }

  function gameLoop() {
    if (!gameActive) return;
    update();
    draw();
    animFrame = requestAnimationFrame(gameLoop);
  }

  // ‚îÄ‚îÄ Start / Stop ‚îÄ‚îÄ

  function startGame() {
    gameActive = true;
    document.getElementById('gameContainer').classList.add('active');
    player.x = 20; player.y = 15;
    starsCollected = 0; npcstalked = 0;
    for (const n of npcs) n.talked = false;
    placeStars();
    generateMap();
    camX = player.x * TILE - W / 2;
    camY = player.y * TILE - H / 2;
    updateHUD();
    gameLoop();
  }

  function stopGame() {
    gameActive = false;
    if (animFrame) cancelAnimationFrame(animFrame);
    document.getElementById('gameContainer').classList.remove('active');
    document.getElementById('gameDialogue').classList.remove('active');
    hideToast();
    dialogueActive = false;
    dialogueQueue = [];
  }

  // ‚îÄ‚îÄ Handle action (space/talk) ‚îÄ‚îÄ

  function handleAction() {
    if (dialogueActive) {
      if (typewriterIdx < typewriterText.length) {
        typewriterIdx = typewriterText.length;
        document.getElementById('dialogueText').textContent = typewriterText;
      } else {
        nextDialogueLine();
      }
    } else if (toastTimer > 0) {
      toastTimer = 0;
      hideToast();
    } else {
      for (const npc of npcs) {
        const dist = Math.abs(player.x - npc.x) + Math.abs(player.y - npc.y);
        if (dist <= 2) {
          if (npc.x < player.x) player.dir = 1;
          else if (npc.x > player.x) player.dir = 2;
          else if (npc.y < player.y) player.dir = 3;
          else player.dir = 0;
          showDialogue(npc);
          break;
        }
      }
    }
  }

  // ‚îÄ‚îÄ Keyboard Input ‚îÄ‚îÄ

  document.addEventListener('keydown', function(e) {
    if (!gameActive) return;
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) {
      e.preventDefault();
    }
    keys[e.key] = true;
    if (e.key === ' ' || e.key === 'Enter') {
      e.preventDefault();
      handleAction();
    }
  });

  document.addEventListener('keyup', function(e) {
    keys[e.key] = false;
  });

  // ‚îÄ‚îÄ Mobile D-pad ‚îÄ‚îÄ

  const dpad = document.getElementById('gameDpad');
  const dirMap = { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight' };
  let touchIntervals = {};

  dpad.addEventListener('pointerdown', function(e) {
    const btn = e.target.closest('button');
    if (!btn) return;
    e.preventDefault();
    const dir = btn.dataset.dir;
    if (dir === 'action') {
      handleAction();
      return;
    }
    const key = dirMap[dir];
    if (!key) return;
    keys[key] = true;
    // Repeat while held
    touchIntervals[dir] = setInterval(() => { keys[key] = true; }, 50);
  });

  function stopTouch(e) {
    const btn = e.target.closest('button');
    if (!btn) return;
    const dir = btn.dataset.dir;
    const key = dirMap[dir];
    if (key) keys[key] = false;
    if (touchIntervals[dir]) { clearInterval(touchIntervals[dir]); delete touchIntervals[dir]; }
  }

  dpad.addEventListener('pointerup', stopTouch);
  dpad.addEventListener('pointerleave', stopTouch);
  dpad.addEventListener('pointercancel', stopTouch);

  // ‚îÄ‚îÄ Buttons ‚îÄ‚îÄ

  document.getElementById('breakBtn').addEventListener('click', function() {
    if (gameActive) stopGame(); else startGame();
  });
  document.getElementById('closeGameBtn').addEventListener('click', stopGame);
})();
</script>
</body>
</html>
